# MRBlog
MixedRealityBlog

Hello this is our blog for the Mixed Reality course :)

# ::::::::::::::::::  WEEK 1  INTRODUCTION AND HISTORY  ::::::::::::::::::::::
18/11/2025
<br/> 
<br/> TECHNOLOGY CHANGES. HUMAN NOT.
<br/> 
<br/> Human-computer interaction is a disciplineconcerned with the design, evaluation andimplementation 
<br/> of interactive computingsystems for human use and with the studyof major phenomena surrounding them.

<br/> “Intuitive design” is a myth: there is no universal intuition; 
<br/> What feels intuitive is often learned and context-dependent 
<br/> Good design leverages real cognitive/perceptual abilities.
<br/> 
<br/> Reality: the world perceived through human senses without a technological mediator.
<br/> 
AR, XR, AR, VR

• Computing Power is growing exponentially
• Storage Capacity is growing exponentially
• Computing technology is changing its shape and complexity
• The human stays almost constant
<br/> 
<br/> Intuitive: using or based on what one feels to be true even withoutconscious reasoning; instinctive.
<br/> 
<br/> 1945_________________Vannevar Bush: MEMEX (hypertext-like ideas). 
<br/> 1963 / 1968__________Ivan Sutherland: Sketchpad ; Sword of Damocles (early tracked HMD).
<br/> 1963 / 1965 / 1968___Douglas Engelbart: mouse; “Mother of All Demos” (NLS: hypertext, collaborative systems). 
<br/> 1972_________________Alan Kay: Smalltalk / object orientation; Dynabook laptop. 
<br/> 1983_________________Stuart Card: The Psychology of Human-Computer Interaction, applying human factors.
<br/> 1986 / 1988__________Don Norman: User-Centered Design framing; Design of Everyday Things.
<br/> 1988_________________Mark Weiser: Ubiquitous Computing.
<br/> 1997_________________Hiroshi Ishii: Tangible User Interfaces (“Tangible Bits / Radical Atoms”).
<br/> 1962_________________Morton Heilig: Sensorama (multi-sensory theater: stereo visuals, sound, wind, vibration, smell)
<br/> 1984_________________Jaron Lanier: VPL Research (headsets/gloves) credited with coining term Virtual Reality
<br/> 1992_________________Carolina Cruz-Neira: CAVE
<br/> 2012_________________Palmer Luckey: Oculus Rift, John Carmack joined as CTO and shaped technical direction

<br/>  VR is next step : PC → mobile → ubiquitous/immersive
<br/>  Stron focus on UX
<br/> 
# ::::::::::::::::::::::::::::  LAB 1 BLOG SETUP :::::::::::::::::::::::::::::
<br/> 

# ::::::::::::::::::::::::  LAB 2 UNITY INSTALLATION  ::::::::::::::::::::::::

<img width="800" height="500" alt="Screenshot 2025-11-25 at 11 21 08" src="https://github.com/user-attachments/assets/ee0e0ee5-105f-4fa4-a361-d130247975af" />

Figure 2.1: Downloading via Safari


<img width="800" height="500" alt="Screenshot 2025-11-25 at 11 22 32" src="https://github.com/user-attachments/assets/26957528-7c14-4db4-8718-ce3886ffaeab" />



Figure 2.2: The infamous "next-next-next" phase


<img width="800" height="600" alt="Screenshot 2025-11-25 at 11 23 12" src="https://github.com/user-attachments/assets/cb49e370-9572-4008-b8d2-a4a3428e929d" />


Figure 2.3: Application install


<img width="800" height="430" alt="Screenshot 2025-11-25 at 11 23 51" src="https://github.com/user-attachments/assets/68b1d505-b6fa-4b78-bdde-5d8358828aba" />


Figure 2.4: Unity has installed

<br/>
<br/>

# ::::::::::::::::::::::::::::::::::   LAB 3 ROLL A BALL   :::::::::::::::::::::::::::::::


STEP 1: SETTING UP THE GAME

<img width="800" height="430" alt="02" src="https://github.com/user-attachments/assets/bbfacea9-42e7-49b5-9b1d-659cb5f7612c" />

Figure 3.1.1: Creating a new Unity project 

<br/> 

<img width="800" height="600" alt="05" src="https://github.com/user-attachments/assets/7ee62294-80dc-48a6-9c6f-e37e6d262079" />

Figure 3.1.2: Using Universal Render Pipeline (URP) 3D template 

<br/>

<img width="800" height="430" alt="04" src="https://github.com/user-attachments/assets/7290cd19-04e8-48e8-a2e8-7d77d0e22262" />

Figure 3.1.3: Unity Editor view of the created project

<br/>

<img width="800" height="452" alt="07" src="https://github.com/user-attachments/assets/b8bf38df-9d49-4330-8444-91d017e55342" />

Figure 3.1.4: Creating a new Scene project using Basic URP template and saving it

<br/>

<img width="800" height="430" alt="3 1 5" src="https://github.com/user-attachments/assets/308d2090-6186-4992-85e8-c78c6d841902" />

Figure 3.1.5: Creating a primitive Plane

<br/>

<img width="800" height="430" alt="3 1 6" src="https://github.com/user-attachments/assets/7764f9e6-cc07-49b5-9106-7217618c7782" />

Figure 3.1.6: Scaling the Ground Plane

<br/>

<img width="800" height="430" alt="3 1 7" src="https://github.com/user-attachments/assets/51f7bf42-5474-4c5a-8638-2e20bf1c27ec" />

Figure 3.1.7: Creating a Player GameObject

<br/>

<img width="800" height="430" alt="3 1 8" src="https://github.com/user-attachments/assets/97e63f97-c45f-4a5d-99ec-62429fed0000" />

Figure 3.1.8: Adjusting the default lighting

<br/>

<img width="800" height="430" alt="3 1 9" src="https://github.com/user-attachments/assets/27f701b5-8b3e-4aaf-b077-3b832f7ccb18" />

Figure 3.1.9: Adding colors with materials

<br/>

STEP 2: MOVING A PLAYER

<img width="800" height="430" alt="3 2 2" src="https://github.com/user-attachments/assets/1257ae69-4d76-4130-9db1-34847dfb7f94" />

Figure 3.2.2: Adding a Rigidbody to the player

<br/>

<img width="800" height="430" alt="3 2 3" src="https://github.com/user-attachments/assets/08aef40b-516c-45fc-b78a-0f8549b9ce1d" />

Figure 3.2.3: Adding a Player Input component

<br/>

<img width="800" height="430" alt="3 2 4" src="https://github.com/user-attachments/assets/ef23e88a-2c4e-4df2-ad36-10319bb3e93d" />

Figure 3.2.4: Creating a new script

<br/>

<img width="800" height="430" alt="3 2 5" src="https://github.com/user-attachments/assets/8cabe794-0603-4049-bb0f-4f4c20e2b4ff" />

Figure 3.2.5: Writing the OnMove function declaration

<br/> 

<img width="800" height="430" alt="3 2 6" src="https://github.com/user-attachments/assets/110ee17b-d99e-4d62-9159-14a47db9c028" />

Figure 3.2.6: Applying input data to the Player

<br/> 

<img src="https://github.com/user-attachments/assets/1d3e916e-6a29-4323-bd18-46ea70c9752a"
     alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.2.7: Applying Force to the Player

<br/> 

<img width="800" height="430" alt="3 2 8" src="https://github.com/user-attachments/assets/459b5492-3c2c-481e-990e-05210780ea10" />

Figure 3.2.8: Fixing the Player movement speed

<br/> 

<img width="800" height="430" alt="3 2 9" src="https://github.com/user-attachments/assets/9745cd9b-716c-462d-bcb2-d1853b20786f" />


Figure 3.2.9: Final Script sample

<br/> 

STEP 3: MOVING THE CAMERA

<img width="800" height="430" alt="3 3 3" src="https://github.com/user-attachments/assets/d70acac8-d2ce-48de-8bbe-3b52907860a0" />

Figure 3.3.3: CameraController Script

<br/> 

<img src= "https://github.com/user-attachments/assets/71b4a429-dbe6-474f-96bc-96bf38323d9b"  
     alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.3.4: Referencing the Player GameObject

<br/> 

<img width="800" height="430" alt="3 3 5" src="https://github.com/user-attachments/assets/ea6f1e57-aa7d-4b3f-82eb-55dbb7d4365f" />

Figure 3.3.5: Commented Final Script

<br/> 

STEP 4: SETTING UP THE PLAY AREA

<img width="800" height="430" alt="3 4 2" src="https://github.com/user-attachments/assets/e83910f3-4d9c-420b-b6e1-3ee27493cee7" />

Figure 3.4.2: Creating a wall for the play field

<br/> 

<img src= "https://github.com/user-attachments/assets/eea3b943-4b0e-496b-8e68-98ff046a7149" 
 alt="3 2 7gif"
     width="800"
     height="430" />


Figure 3.4.3: Finishing the play field walls

<br/> 

STEP 5: CREATING COLLECTIBLES

<img width="800" height="430" alt="3 5 2" src="https://github.com/user-attachments/assets/b6cfb979-0256-4ddd-94b3-d03036f78db5" />

Figure 3.5.2: Creating a collectible GameObject

<br/> 

<img src="https://github.com/user-attachments/assets/58988a2e-d900-4cc1-b9ca-0ed666581dcb"
 alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.5.3: Rotating the PickUp GameObject

<br/> 

<img width="800" height="430" alt="3 5 4" src="https://github.com/user-attachments/assets/4779a582-5bc6-43e7-bd8e-41a2787cc67d" />

Figure 3.5.4: Making PickUp a Prefab

<br/> 

<img src= "https://github.com/user-attachments/assets/9b2b1a4c-ba53-4485-8756-55f74f0f7f08"
 alt="3 2 7gif"
     width="800"
     height="430" />


Figure 3.5.5: Adding more collections

<br/> 

<img width="800" height="430" alt="3 5 6" src="https://github.com/user-attachments/assets/ed77034e-883f-49fb-8fc0-2c91895c4892" />

Figure 3.5.6: Final Script

<br/> 

STEP 6: DETECTING COLLISIONS WITH COLLECTIBLES

<img width="800" height="430" alt="3 6 2" src="https://github.com/user-attachments/assets/30dd0d72-3283-4f83-b81e-6fc2ba5c0ace" />

Figure 3.6.2: Disabling PickUps with OnTriggerEnter

<br/>

<img width="800" height="430" alt="3 6 3" src="https://github.com/user-attachments/assets/470bad59-4c4a-4266-ae5a-650b6e42af77" />

Figure 3.6.3: Adding a tag to the PickUp Prefab

<br/>

<img src="https://github.com/user-attachments/assets/106355f3-6fba-48a7-ad93-f4e630851dc6"
 alt="3 2 7gif"
     width="800"
     height="430" />
     
Figure 3.6.4: Writing a conditional statement

<br/>

<img src="https://github.com/user-attachments/assets/f4a037c0-6a62-4672-8bac-d3c240d30341"
 alt="3 2 7gif"
     width="800"
     height="430" />


Figure 3.6.5: Set the Pickup Colliders as triggers

<br/>

<img width="800" height="430" alt="3 6 6" src="https://github.com/user-attachments/assets/37cde26b-fd2d-47b0-9d96-2add9e7c69b2" />

Figure 3.6.6: Adding a Rigidbody component to the PickUp Prefab and meking it kinematic
 <br>
 <br>
Static colliders shouldn't move like walls and floors. <br>
Dynamic colliders can move and have a Rigidbody attached. <br>
Standard Rigidbodies are moved using physics forces. <br>
Kinematic Rigidbodies are moved using their transform. <br>

<br>

<img width="800" height="430" alt="3 6 7" src="https://github.com/user-attachments/assets/6fdd559d-c76d-496a-98cc-d53c2c4f912c" />

Figure 3.6.7: Final Script

<br/>

STEP 7: DISPLAYING SCORE AND TEXT

<img width="800" height="430" alt="3 7 2" src="https://github.com/user-attachments/assets/e2c8802f-e5e8-4057-9a19-f94aea645c6f" />

Figure 3.7.2: Storing the value of collected PickUps

<br/>

<img width="800" height="430" alt="3 7 3" src="https://github.com/user-attachments/assets/18c5696e-592d-42e1-bd62-a9a15683ce73" />

Figure 3.7.3: Creating a UI text element

<br/>

<img src= "https://github.com/user-attachments/assets/6ae50967-d30d-46ce-b843-710652f71d67"
 alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.7.4: Displaying the count value

<br/>

<img src= "https://github.com/user-attachments/assets/7970347e-11e8-49c7-bc9c-00bb8da88ad8"
 alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.7.5: Creating a UI text element

<br/>

<img width="800" height="430" alt="3 7 6" src="https://github.com/user-attachments/assets/f988c92f-0b58-4fdd-8e7a-bd9e36cac6f5" />

Figure 3.7.6: Final script

<br/>

STEP 8: ADDING AI NAVIGATION

<img width="800" height="430" alt="3 8 2" src="https://github.com/user-attachments/assets/efcd02e7-d0b1-42f5-869f-c5517a3c07d5" />

Figure 3.8.2: Creating an enemy

<br/>

<img width="800" height="430" alt="3 8 3" src="https://github.com/user-attachments/assets/e5fd867a-d637-41e8-83ca-120b3ff684ad" />

Figure 3.8.3: Baking a NavMesh

<br/>

<img src= "https://github.com/user-attachments/assets/019b4381-de08-4e5a-a616-e38c9bed8889"
 alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.8.4: Making the enemy chaise the player

<br/>

<img width="800" height="430" alt="3 8 5" src="https://github.com/user-attachments/assets/7c63bce7-af59-4b3d-b2c3-778dd97f8995" />

Figure 3.8.5: Creating static obstacles

<br/>

<img src= "https://github.com/user-attachments/assets/13ac9441-8a19-48b9-92e8-d341271343e3"
 alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.8.6: Creating dynamic obstacles

<br/>

<img src= "https://github.com/user-attachments/assets/189eaa4b-a7f2-4f03-a660-24f8aac01d9f"
 alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.8.7.1: Setting the lose condition

<br/>

<img width="800" height="51" alt="bug" src="https://github.com/user-attachments/assets/2df95d04-d5b3-42aa-8839-2fbbcc664ae8" />

Side note: Bug message after loosing

<br/>

<img width="800" height="430" alt="3 8 7 2" src="https://github.com/user-attachments/assets/d11b96e5-0481-4fb4-87b1-559b0bb46a5d" />

Figure 3.8.7.2: Setting the win condition

<br/>

STEP 9: BUILDING THE GAME

<img width="800" height="430" alt="3 9 2" src="https://github.com/user-attachments/assets/a1abf96a-ea53-4b8e-9578-2d8cbef51d05" />


Figure 3.9.2: Build for Windows

<br/>

STEP 10: EXTRA FEATURE: RESTART OPTION

<br/> 1. Created empty GameObject => RestartManager, created gameEnded flag
<br/> 2. Created RestartManager.cs script and attached it to RestartManger object
<br/> 3. Selected the Player and drugged RestartManager object into restartManager field
<br/> 4. Modified the Enemy, tagged the Player tag to the Player object
<br/> 5. Modified win and lose text by adding "Press R to restart"

<br/>

<img width="800" height="430" alt="3 10 0" src="https://github.com/user-attachments/assets/04294862-1adc-4767-8ddf-8a264cbe15f8" />

Figure 3.10.1: Added GameEnded flag

<br/>

<img width="800" height="430" alt="3 10 1" src="https://github.com/user-attachments/assets/68cb712a-34d2-4dd9-9bcb-3da38989fa0e" />

Figure 3.10.2: Restart Manager script

When the game ends (win or lose), a global RestartManager sets a gameEnded flag. 
<br/> While this flag is true, the manager listens for the R key and reloads the current scene, 
<br/> fully resetting the level (player, enemy, pickups).
<br/> This logic is kept outside the Player so it still works even if the Player is destroyed.

<br/>

<img width="800" height="430" alt="3 10 2" src="https://github.com/user-attachments/assets/8a1e6bb4-45e8-42c6-9b70-d9fe037a1276" />

Figure 3.10.3: Enemy movement script

The enemy originally relied on a fixed reference to the Player. 
<br/> When the Player was destroyed (on lose) or not assigned, the enemy stopped moving.
<br/> The script was modified to safely handle the Player reference and the game state.
<br/>
<br/> The enemy now checks if the Player exists before moving.
<br/> If the Player is missing, the enemy waits or re-finds the Player instead of breaking.
<br/> Movement is only applied when the NavMeshAgent is valid and on the NavMesh.



<br/>

<img src= "https://github.com/user-attachments/assets/f0fa9f9c-9e2c-4e0c-be3b-163bcc245940"
 alt="3 2 7gif"
     width="800"
     height="430" />

Figure 3.10.4: Restart demo

<br/>

# ::::::::::::::::::::::::::  LAB 3 LOCOMOTION IDEAS  ::::::::::::::::::::::::::

<div style="position:relative;padding-top:56.25%;">
  <iframe
    src="https://docs.google.com/presentation/d/e/2PACX-1vT43i_otFYE3wyMAsoZYFqYUv_YvU4wDNmdpfwElkzkPIlhVLurxAyGZwcqkAYoiw9Sx5JqE3_ezAsg/pubembed?start=false&loop=false&delayms=3000"
    style="position:absolute;top:0;left:0;width:90%;height:90%;"
    frameborder="0"
    allowfullscreen></iframe>
</div>

<br/>

# ::::::::::::::::::::::::  LAB 4 UNITY ROLL-A-BALL IN VR  ::::::::::::::::::::::::

<br/>

# :::::::::::::::::::::::::  LAB 5 LOCOMOTION TECHNIQUE  :::::::::::::::::::::::::

Idea Presentation
<div style="position:relative;padding-top:56.25%;">
  <iframe
    src="https://docs.google.com/presentation/d/e/2PACX-1vQY3CyzyLxw8x0Vd3gvsZfmmsqBiKGpsKcpJcPJCg2TJY6LuLJmirgr2W_qVhekI_w89vyJ94VUwPaH/pubembed?start=false&loop=false&delayms=3000"
    style="position:absolute;top:0;left:0;width:90%;height:90%;"
    frameborder="0"
    allowfullscreen></iframe>
</div>

<br/> The idea was simple:
<br/>
<br/> 1. Hold the right index trigger to aim the movement direction with the right controller.
<br/> 2. Release it the direction freezes.
<br/> 3. Use the left thumbstick Y to control acceleration, so speed goes up/down over time.
<br/> 4. Move the player in that direction (or the opposite if the accelaration is neative)
<br/> 5. Visualize speed and vector
<br/>
<br/> 1 Problem: At first, the direction update was inconsistent. The controller forward vector was correct, 
<br/> but it didn’t match the world direction.
<br/> 
<br/> 1 Solution We made sure the controller forward is converted properly into world space using the rig’s 
<br/> TrackingSpace: get controller rotation in local tracking space. Convert the forward vector to world.
<br/>
<br/> 2 Problem: Speed number appeared not correct. Actual movement felt the same no matter what maxSpeed was.
<br/> 2 Solution: We realized we were moving the wrong thing. So instead of moving transform.position, 
<br/> we moved the rig root, which lead us to the =>
<br/>
<br/> 3 Problem: After switching to moving the rig root, the movement suddenly felt like it had no cap.
<br/> 3 Solution: We added a debug display: what we think speed is and (cmd) how fast it actually moved (real)
<br/> We used the real speed check and also learned to search the scene for duplicate locomotion scripts.
<br/> Once only one script was moving the rig, the limit behaved normally again.
<br/>
<br/> 4 Problem: Tha text appearnce was no as we planned: wrong TextMesh material, mirrored text, font size, etc..
<br/> 4 Solution: We stopped doing “LookAt every frame” and used a local rotation, chaned material, font
<br/>
<br/> 5 Problem: teleport arc/pointer from Oculus locomotion (in pink)
<br/> 5 Solution: We disabled the teleport/aim handler components that draw arcs
<br/>

Final Presentation
<div style="position:relative;padding-top:56.25%;">
  <iframe
    src="https://docs.google.com/presentation/d/e/2PACX-1vSalGj1A8zIeug_diUBi9YCq93IngNM8SI05j-1CGngrsIxFitwwCQluSKJLp2ez6LMVRa5Ga7HvlO2/pubembed?start=false&loop=false&delayms=3000"
    style="position:absolute;top:0;left:0;width:90%;height:100%;"
    frameborder="0"
    allowfullscreen></iframe>
</div>

<br/>

